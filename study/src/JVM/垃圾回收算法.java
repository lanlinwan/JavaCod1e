package JVM;

public class 垃圾回收算法 {
    //垃圾对象判定标准
    //  JVM的GC工作主要针对的对象是堆内存，在做GC工作之前，首先要判定堆内存中的对象实例是否为垃圾，通常使用以下两种算法来定义
    // 1.引用计数算法
    //   java在运行时，当有一个地方引用该对象实例，会将这个对象实例加1，引用失效时就减1，
    //   jvm在扫描内存时，发现引用计数值为0的则是垃圾对象，计数值大于0的则为活跃对象。
    //   目前垃圾回收算法，没有采用引用计数算法，原因是在对象互相引用的情况下，无法判定两者是否为垃圾对象。
    // 2.根搜索算法
    //   根搜索算法是以“GC ROOTS”为起始点往下搜索，所有经过的对象合并起来称为引用链，在这引用链里，没有的对象称为垃圾对象，
    //   （实际上jvm还做了一个筛选动作，判定当前对象是否执行finalize()方法，如果不需要执行才判定为垃圾对象），在引用链里的是活跃对象。
    //   以下四种对象称为“GC ROOTS”:
    //   1.虚拟机栈（栈帧中的本地变量表）中引用的对象。
    //   2.方法区中的类静态属性引用的对象。
    //   3.方法区中的常量引用的对象。
    //   4.本地方法栈中 JNI（Native 方法）的引用对象。

    //垃圾回收算法
    //1.标记清除: 一般不用了
    //  分为两个阶段：标记阶段和清除阶段
    //      在标记阶段首先通过根节点(GC Roots)，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。
    //      然后，在清除阶段，扫描整个内存空间,清除所有未被标记的对象。
    //  优点：清理效率高，实现起来比较简单。
    //	缺点：需要暂停整个应用,容易产生大量的「内存碎片」,两次扫描
    //  应用：标记-清除算法通常是「配合标记-整理算法」使用

    //2.标记整理:
    //  是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。
    //  首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，
    //  而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。
    //  优点：这种方法既避免了碎片的产生，又不需要两块相同的内存空间
    //  缺点:需要整理所有存活对象的引用地址,效率降低


    //3.标记复制:
    //  复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的,一般用于新生代
    //  从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象复制到一块儿新的内存上去，
    //  之后将原来的那一块儿内存全部回收掉

    //4.分代收集算法
    //  分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），
    //  在堆区之外还有一个代就是永久代（Permanet Generation）。
    //  在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。

//    面试题:说说GC和分代回收算法
//    ●GC 的目的在于实现无用对象内存自动释放,减少内存碎片、加快分配速度
//    GC要点:
//     ①回收区域是堆内存，不包括虚拟机栈,在方法调用结束会自动释放方法占用内存
//     ②判断无用对象，使用可达性分析算法，三色标记法标记存活对象，回收未标记对象
//     ③GC具体的实现称为垃圾回收器
//     ④GC 大都采用了分代回收思想，理论依据是大部分对象朝生夕灭，用完立刻就可以回收,另有少部分对象会长时间存活，每次
//      很难回收，根据这两类对象的特性将回收区域分为新生代和老年代,不同区域应用不同的回收策略
//     ⑤根据 GC的规模可以分成Minor GC, Mixed GC, Full GC
//
//    ●分代回收:
//    ①伊甸园 eden,最初对象都分配到这里，与幸存区合称新生代
//    ②幸存 区survivor,当伊甸园内存不足，回收后的幸存对象到这里，分成from和to,采用标记复制算法
//    ③老年代 old,当幸存区对象熬过几次回收(最多15次)，晋升到老年代(幸存区内存不足或大对象会导致提前晋升)
//    GC规模
//    ①Minor GC发生在新生代的垃圾回收,暂停时间短
//    ②Mixed GC新生代+老年代 部分区域的垃圾回收, G1收集器特有
//    ③Full GC新生代+老年代 完整垃圾回收，暂停时间长，应尽力避免
//
//
//    三色标记与并发漏标问题
//    1.用三种颜色记录对象的标记状态
//    ① 黑色-已标记
//    ② 灰色-标记中
//    ③ 白色-还未标记
//    2.漏标问题 -记录标记过程中变化
//    ① Incremental Update
//    ① 只要赋值发生， 被赋值的对象就会被记录
//    ② Snapshot At The Beginning, SATB
//    ① 新加对象会被记录
//    ② 被删除引用 关系的对象也被记录



}
