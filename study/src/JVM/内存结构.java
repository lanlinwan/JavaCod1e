package JVM;

public class 内存结构 {
    public static void main(String[] args) {
        //内存结构:
        //   线程共享: 方法区:
        //               用于存储JVM加载完成的类型信息、常量、静态变量、运行常量池,即时编译器编译后的代码缓存,
        //               方法区也可以被垃圾回收，但条件非常严苛，必须在该类没有任何引用的情况下;
        //           堆:
        //              负责存放对象实例，当Java创建一个类的实例对象或者数组时，都会在堆中为新的对象分配内存
        //              通常情况下，堆占用的内存空间是最多的,堆的存取方式为管道类型，先进先出,在程序运行中，可以动态的分配堆的内存大小。
        //   线程私有: 程序计数器:
        //               JVM节码解释器工作时 就是通过读取程序计数器的值来决定下一条需要执行的字节码指令，进而进行选择语句、循环、异常处理等程恢复等基础功能;
        //               程序计数器不会抛出 OutOfMemoryError（内存不足错误）。
        //               记录java文件编译后的class文件 执行的字节码行号,在线程切换后可以根据程序计数器记录的字节码行号 继续执行下一条字节码命令
        //           本地方法栈:
        //               Native关键字，凡是被Native修饰的方法， 都会去调用底层的C语言的库，会调用JNI接口(本地方法接口)，比如，java驱动打印机打印,
        //           Java虚拟机栈:
        //               每个线程运行所需要的内存,称为虚拟机栈
        //               由栈帧组成，存放局部变量表、操作栈、动态链接、方法出口等信息，方法的执行对应着 栈帧的入栈到出栈的过程。
        //               Java 虚拟机栈的生命周期和线程对应，在线程创建的同时创建，和程序计数器一样都是线程私有内存区域。
        //    在HotSpot虚拟机中 本地方法栈 和Java虚拟机栈 合为一。



        //●方法区与永久代、元空间之间的关系
        //①方法区是JVM规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等
        //②永久代是Hotspot虚拟机对jVM规范的实现(1.8之前)
        //③元空间是Hotspot虚拟机对JVM规范的实现(1.8以后)，使用本地内存作为这些信息的存储空间

        //●哪些部分会出现内存溢出?
        //不会出现内存溢出的区域-程序计数器
        //出现OutOfMemoryError的情况:
        //  ①堆内存耗尽-对象越来越多,又-直在使用,不能被垃圾回收
        //  ②方法区内存耗尽-加载的类越来越多，很多框架都会在运行期间动态产生新的类
        //  ③虚拟机栈累积-每个线程最多会占用1 M内存，线程个数越来越多,而又长时间运行不销毁时
        //出现StackOverflowError的区域:
        //  ①虚拟机栈内部 -方法调用次数过多

        //说一下堆栈的区别?
        //物理地址:
        //  堆的物理地址分配对对象是不连续的。在GC的时候需要考虑到不连续的分配，性能较慢。
        //  栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。性能快。
        //存放的内容:
        //  堆存放的是对象的实例和数组。
        //  栈存放:局部变量,操作数栈，返回结果。
        //垃圾回收:
        //  堆会因为内存不足进行垃圾回收
        //  栈因为方法执行完毕就会释放内存,不会进行垃圾回收
        //程序的可见度:
        //  堆对于整个应用程序都是共享、可见的。
        //  栈只对于线程是可见的，线程私有。


    }
}
