package JVM;

public class 类加载器 {
    //JVM将指定的class文件读取到内存里，并运行该class文件里的Java程序的过程，就称之为类的加载；
    // 反之，将某个class文件的运行时数据从JVM中移除的过程，就称之为类的卸载。

    //加载规则:
    //   JVM 启动的时候,并不会一次性加载所有的类,而是根据需要去动态加载。也就是说,
    //   大部分类在具体用到的时候才会去加载,这样对内存更加友好。

    //类的实例化顺序?
    //1.父类中的static代码块，当前类的static
    //2.顺序执行父类的普通代码块
    //3.父类的构造函数
    //4.当前类普通代码块
    //5.当前类的构造函数

    //，类加载器在JVM中的作用有：
    // 1.将类的字节码文件从JVM外部加载到内存中
    // 2.确定一个类的唯一性
    // 3.提供隔离特性，为中间件开发者提供便利，例如Tomcat

    //面试题:类加载过程、双亲委派

    //●类加载过程分为三个阶段
    //1. 加载
    //①将类的字节码载 入方法区,并创建类.class对象
    //②如果此类的父类没有加载, 先加载父类
    //③加载是懒惰执行
    //2.链接
    //①验证-验证类是否符合Class规范,合法性、安全性检查
    //②准备- 为static变量分配空间,设置默认值
    //      被final修饰的static常量，会直接赋予原值;类字段的字段属性表中存在ConstantValue属性，则在准备阶段,
    //      其值就是ConstantValue的值)
    //③解析-将常量池的符号引用解析为直接引用
    //3.初始化
    //①执行静态代码块与 非final 的 static变量的赋值
    //②初始化是懒惰执行
    //注意:*final修饰的static常量，在编译阶段,就会将该值放到常量池中,类不需要被加载完成。
    //     只要执行到 加载 -> 连接 ( 验证 , 准备 , 解析 ) 阶段 , 就可以完成常量池的初始化 , 即使没有执行 初始化 这个步骤 , 也不影响使用类中的常量值 ;
    //    *final修饰的是static变量的对象，在运行时才能确定它的值，需要加载类。
    //4.使用 ：程序代码执行时使用，new出对象程序中使用。
    //5.卸载 ：程序代码退出、异常、结束等，执行垃圾回收。


    //         名称              加载哪的类                    说明
    //Bootstrap ClassLoader    JAVA_ HOME/jre/lib        无法直接访问.
    //  启动加载类:最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库

    //Extension ClassLoader    JAVA_ HOME/jre/lib/ ext   上级为Bootstrap, 显示为null
    //  扩展类加载器:主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类以及被 java.ext.dirs 系统变量所指定的路径下的所有类

    //Application ClassLoader  classpath                 上级为Extension
    //  系统类加载器:面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

    //自定义类加载器              自定义                    上级为Application

    //●何为双亲委派
    //所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果. 上级类加载器
    //①能找到这个类，由上级加载,加载后该类也对下级加载器可见
    //②找不到这个类,则下级类加载器才有资格执行加载
    //作用:确定了加载的路径，保证了核心类库的安全性
    //●双亲委 派的目的有两点
    //①让上级类加载器中的类对下级共享(反之不行)，即能让你的类能依赖到jdk提供的核心类
    //②让类 的加载有优先次序，保证核心类优先加载

    //好处:
    //1.避免重复加载:由于类加载器会在其加载的类中缓存已经加载的类,所以使用双亲委派模型可以
    //  避免重复加载同一个类,从而节省内存空间。
    //2.防止类库被篡改:由于父类加载器可以优先加载类库，因此双亲委派模型可以避免用户篡改Java核心类库等安全问题。
    //3.保证类的一致性:如果父类加载器已经加载了一个类,子类加载器再次尝试加载该类时，由于双
    //  亲委派模型的存在，子类加载器将不会再次加载该类，而是直接使用父类加载器所加载的类,从而保证类的一致性。
    //4.支持类的版本管理:由于Java类库升级时，只需要升级父类加载器中的类库即可，从而避免类库版本不一致的问题。
}
