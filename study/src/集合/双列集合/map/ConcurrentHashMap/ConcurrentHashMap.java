package 集合.双列集合.map.ConcurrentHashMap;

public class ConcurrentHashMap {
    public static void main(String[] args) {
        //ConcurrentHashMap是线程安全的HashMap。专门用于多线程环境。
        //
        //HashTable是线程安全的,但是HashTable只是单纯的在put()方法上加上synchronized。
        //保证插入时阻塞其他线程的插入操作。虽然安全，但因为设计简单，所以性能低下。

        //7:
        //JDK1.7 中的 ConcurrentHashMap 是由 Segment 数组结构(容量:2的n次方,默认16)和 HashEntry(key,value) 数组结构组成，
        //即 ConcurrentHashMap Segment 数组中每一个Segment下都有 一个 HashEntry数组
        //每一个 Segment都是一把锁,并发度就是Segment数组的容量,当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现了真正的并发访问

        //ConcurrentHashMap(capacity,factor,clevel) 构造器,三个参数:总容量,扩容因子,并发度
        // 总容量/并发度 会得到HashEntry数组的容量(最小为2);
        // HashEntry数组元素数量>HashEntry数组的容量*扩容因子 会进行2倍扩容,Segment[]下的HashEntry[] 扩容互不影响
        // 并发度 = Segment数组的容量
        // ConcurrentHashMap创建后 只有Segment[0] 有 HashEntry[],后面的Segment会按照Segment[0]为原型进行创建

        //put: Segment数组的下标:假设大数组长度是 2^n , key 的二次hash后的值,找 二进制后 高 n位 转为10进制 ;
        //     HashEntry数组下标:假设小数组长度是 2^n , key 的二次 hash的值,找 二进制后 低 n 位转为10进制(插入为头插法);


        //8:
        //jdk8 中的 ConcurrentHashMap 数据结构同 jdk8 中的 HashMap 数据结构一样，都是 数组+链表+红黑树。
        // 摒弃了 jdk7 中的分段锁设计，使用了 Node + CAS(乐观锁) + Synchronized 来保证线程安全。

        //ConcurrentHashMap(capacity,factor),两个参数:假设要放入元素的数量,第一次创建使用的的 扩容因子,
        // ConcurrentHashMap创建后 数组不会进行创建,第一次添加后才会进行创建,
        // 如果两个参数 capacity=12,factor=0.75 : 创建的数组容量 = 能容纳 放入元素的数量 2^n(比如放入12个,(12/0.75=16),会创建32(2^5)容量的数组)
        //扩容:数量 = 容量*扩容因子 进行2倍扩容

        //put: 首节点
        //1.先校验一个 k 和 v 都不可为空。
        //2.判断 table 是否为空,如果为空,cas创建数组，失败继续自旋（for 死循环），直到成功。
        //3.如果发现插入位置的 bucket 为空，通过 CAS新增 把键值对插入到这个桶中作为头节点。
        //4.如果这个要插入的桶中的 hash 值为 - 1，也就是 MOVED 状态（也就是这个节点是 forwordingNode）,那就是说明有线程正在进行扩容操作，那么当前线程就进入协助扩容阶段。
        //5.如果插入位置有值,synchronized 锁住当前 头节点, 如果这个节点是一个链表节点，根据 key 匹配结果去决定是插入还是覆盖，插入是用尾插法。
        //  如果这个节点是一个红黑树节点，那就需要按照树的插入规则进行插入。
        //6.插入结束之后判断该链表节点个数是否到达8，如果是就把链表转化为红黑树存储。
        //7.put 结束之后，需要给 map 已存储的数量 +1，在 addCount 方法中判断是否需要扩容。

        //扩容:机制和hashMap 差不多
        //1.首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝；
        //2.拷贝数组的槽点时，先把原数组 槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时，把原数组槽点赋值为转移节点；
        //3.这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在扩容完成之前，该槽点对应的数据是不会发生变化的；
        //4.从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点；
        //5.直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。

        //get:
        //不需要加锁,保证 put 的时候线程安全之后，get 的时候只需要保证可见性即可，而可见性不需要加锁。

        //size:
        //1.7 有个尝试的思想，当调用 size 方法的时候不会加锁，而是先尝试三次不加锁获取 sum。
        //  如果三次总数一样，说明当前数量没有变化，那就直接返回了。如果总数不一样，那说明此时有线程在增删 map，于是加锁计算，这时候其他线程就操作不了 map 了。
        //而 1.8 不一样，它就是直接计算返回结果，具体采用的是类似 LongAdder 的思想，累加不再是基于一个成员变量，而是搞了一个数组，每个线程在自己对应的下标地方进行累加，
        //  等最后的时候把数组里面的数据统一一下，就是最终的值了。


    }
}
