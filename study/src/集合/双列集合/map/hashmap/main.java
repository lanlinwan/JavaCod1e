package 集合.双列集合.map.hashmap;

import java.util.HashMap;

public class main {
    public static void main(String[] args) {
        //HashMap的特点:
        //①HashMap是Map里面的一个实现类。
        //②没有额外需要学习的特有方法，直接使用Map里面的方法就可以了。
        //③特点都是由键决定的:无序、不重复、无索引
        //④HashMap跟HashSet底层原理是一模一样的，都是哈希表结构
        //HashMap底层:
        //1. HashMap底层是哈希表结构的
        //2.依赖hashCode方法和equals方法保证键的唯一
        //3.如果键存储的是自定义对象，需要重写hashCode和equals方法
        //如果值存储自定义对象，不需要重写hashCode和equals方法

        //面试:
        //1.底层数据结构,1.7 与 1.8 有何不同: 1.7是数组+链表;  1.8是数组+(链表||红黑树)


        //2.初始化:JDK1.7的时候初始容量是16，但是JDK1.8的时候初始化HashMap的时候并没有指定容量大小，
        //  而是在第一次执行put数据，才初始化容量为16。
        //  HashMap是将传入的数转换成比它大的最近的2的n次方的数。有点拗口。

        //3.扩容: 1.7是 添加元素前 时  超过容量阈值(3/4)  且 插入的桶下标位置已有节点占用 时才进行2倍扩容，
        //
        //       1.8是大于阈值就扩容:初始化时,添加节点结束之后和判断树化的时候都会去判断扩容。
        //          添加节点结束之后只要size大于阈值，就一定会扩容，是一个条件。
        //       1.元素总数 超过容量 3/4 进行 2倍扩容
        //       或者
        //       2.链表长度=8时,每添加一次元素,会先进行扩容，尝试解决链表长度过长问题,直到容量 >=64,此时链表长度>=8 进行红黑树化

        //  扩容机制:●在添加元素或者初始化的时候 会调用resize方法进行扩容操作,第一次添加元素 初始化数组容量为16
        //          之后每次达到阈值(0.75)扩容,每次扩容之前容量的两倍
        //         ●扩容之后,会创建一个新的数组,需要把老数组的数据挪动到新的数组中
        //           ●没有hash冲突的节点,使用 e.hash & (newCap-1)(就是节点hash值%新数组长度)计算新数组的索引位置
        //           ●是红黑树,走红黑树添加
        //           ●是链表:对链表进行遍历,可能需要拆分,判断 e.hash & oldCap 是否为0
        //            为0 停留在原位置, 不为0 移动到 原始位置+增加的数组大小 位置
        //


        //4.底层对一个元素进行 储存时会对其进行 hashcode运算,再进行hash运算,再对数组长度 取模获得存入的索引下标(桶下标)
        //  当桶下标相同 会形成 链表挂在同一个桶下标下,jdk1.7有可能会出现 桶下标大量相同,查询缓慢
        //  扩容可以解决 桶下标 大量相同的问题,但是解决不了 大量元素 hash值相同的问题(hash值相同,桶下标永远相同)

        //5. 1.8红黑树化: 两个条件同时满足: 1.链表长度超过一个树化域值(8)  2.数组容量 大于64



        //问题:
        //●为何要用红黑树，为何一.上来不树化，树化阈值为何是8,何时会树化，何时会退化为链表?
        //在链表过长的情况下会影响查询的性能
        //①红黑树用来避免DoS攻击,防止链表超长时性能下降,树化应当是偶然情况
        //  ①hash表的查找，更新的时间复杂度是0(1),而红黑树的查找，更新的时间复杂度是0(log2 n), TreeNode占用空间也比普通Node的大，
        //      如非必要,尽量还是使用链表。
        //  ②hash值如果足够随机，则在hash表内按泊松分布,在负载因子0.75的情况下，长度超过8的链表出现概率是0.00000006(千万分之6)，
        //      选择8就是为了让树化几率足够小
        //②树化两个条件: 链表长度超过树化阈值;数组容量>= 64
        //③退化情况1: 在扩容时 如果拆分树时，树元素个数<= 6则会退化链表, 不是8的原因:避免反复进行 树化,拆分
        //④退化情况2: remove 树节点前(注意是删除前检查)，若root、root.left、 root.right、 root.left.left 有-个为null ,也会退化为链表

        //●索引如何计算? hashCode 都有了,为何还要提供hash()方法?数组容量为何是2的n次幂?
        //①计算对象的 hashCode()，再进行调用HashMap的hash()方法进行二次哈希,最后  %数组容量得到索引:(97 % 16=1)
        //  这里会优化为  二次hash值 & (容量数量- 1): (97 & (16-1)),运算效率更高,但是 除数必须是 2n次方 才能进行优化
        //②二次 hash()是为了综合高位数据,让哈希分布更为均匀
        //③计算索引时， 如果是2的n次幂可以使用位与运算代替取模,效率更高;扩容时 hash & oldCap == 0的元素留在原来位置，否
        //  则新位置=旧位置+ 旧的容量
        //④但①.②、③都是为了配合容量为2的n次幂时的优化手段,例如Hashtable的容量就不是2的n次幂,并不能说哪种设计更
        //  优，应该是设计者综合了各种因素,最终选择了使用2的n次幂作为容量
        //⑤ 更高的效率使用 2的n次幂为数组容量;  更好的hash分布性使用 质数为数组容量

        //●介绍一下put方法流程,1.7与1.8有何不同?
        //1.8:
        //①HashMap 是懒惰创建数组的，首次使用才创建数组
        //②计算索引 (桶下标)
        //③如果桶下标还没人占用， 创建Node占位返回
        //④如果桶下标已经有人占用,进行equal比较,相同取代,不同则:
        //      1已经 是TreeNode走红黑树的添加或更新逻辑
        //      2是普通 Node,走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑
        //⑤返回前检查容量 是否超过阈值, 一旦超过进行扩容(元素放进去再扩容）
        //⑥不同
        //  1. 链表插入节点时，1.7是头插法，1.8是尾插法
        //  2. 1.7是大于等于阈值且 插入的桶下标位置已有节点占用 时才扩容，而1.8是大于阈值就扩容
        //  3. 1.8在扩容计算Node索引时，会优化

        //●加载因子为何默认是0.75f
        //①在空间占用与查询时间之间取得较好的权衡
        //②大于这个值， 空间节省了,但链表就会比较长影响性能
        //③小于这个值， 冲突减少了,但扩容就会更频繁，空间占用多

        //●多线程下会有啥问题?
        //①扩容死链(1.7)
        //  因为 1.7添加元素 是头插法,多个线程同时扩容
        //②数据错乱(1.7, 1.8)
        // 并发线程同时添加元素到 同一个桶下标下,都进入到 判断该桶下标为空节点,
        // 先添加的元素 会被后添加的元素覆盖造成数据丢失

        //●key能否为null, 作为key的对象有什么要求?
        //①HashMap 的key可以为null,但是null作为key只能有一个,会被存入下标为0位置上,null作为value可以有多个,但Map的其他实现则不然
        //②作为 key的对象,必须实现hashCode和equals,并且key的内容不能修改(不可变,否则 hash运算后的值会变)

        //●String对象的hashCode()如何设计的,为啥每次乘的是31
        //●目标是达到较为均匀的散列效果， 每个字符串的hashCode足够独特
        //①字符串中的每 个字符都可以表现为一一个数字,称为Si,其中i的范围是0~n-1
        //②散列公式为: So* 31n-1+S1* 31n-2+ ..Ss * 31n-1-i+ ..Sn-1*310
        //③31 代入公式有较好的散列特性,并且31 * h可以被优化为
        //   ①即32*h-h
        //   ②即25 *h-h
        //   ③即h《5 -h

    }


}
