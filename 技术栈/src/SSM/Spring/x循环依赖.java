package SSM.Spring;

public class x循环依赖 {
    //Spring的循环依赖，也就是两个bean之间产生了互相依赖
    //SSM.Spring

    //bean的实例化，就是将bean的对象new出来，称为bean的原始对象，原始对象没有完成属性注入，不能称为bean；
    //bean的属性注入，就是为bean的原始对象注入其它bean即依赖注入，完成依赖注入的原始对象，此时可以作为bean放入容器；
    //bean的初始化可以理解为：bean实例化 + bean属性注入
    //

    //一级缓存用于存放 已经完成了所有创建的生命周期过程的bean或者 代理bean，如果bean需要生成动态代理对象，
    // 那它们在一级缓存中存放的就是它们的代理bean，后续容器中任何地方使用A和B，都是使用的一级缓存中它们的代理bean。

    //二级缓存:存放半成品 就是已经完成实例化，但是还没有属性赋值的对象和初始化操作,bean完成实例化就会放入二级缓存
    //为了方便被别的bean引用

    //三级缓存:用于处理存在 AOP 时的循环依赖问题
    //存的是每个Bean对应的ObjectFactory对象，通过调用这个对象的getObject方法，就可以获取到早期暴露出去的Bean。
    //注意：这里有个很重要的细节就是三级缓存只会对单例的Bean生效，像多例的是无法利用到三级缓存的，通过三级缓存所在的类名DefaultSingletonBeanRegistry就可以看出，仅仅是对SingletonBean也就是单例Bean有效果。
    //3级缓存的作用 主要是为了正常情况下，代理对象能在初始化完成后生成，而不用提前生成

    //正常不存在循环依赖的A、B对象是依次创建的，但是如果存在循环依赖的话，创建A的过程中，会顺便把B也创建了。注意，每次获取bean对象都会先去一级缓存看有没有值。
    //具体流程是：
    //1、遍历待创建的所有beanName，第一次遍历，开始获取A，此时缓存中没有，会开始正常创建流程
    //2、A初始创建完成，然后判断A是否是单例，且没有创建完毕，如果是，那么就会把A的beanFactory存入三级缓存
    //3、A开始处理@Autowired注解，开始注入B属性，于是尝试从缓存获取B，获取不到，则开始正常创建B的流程
    //4、B初始创建完成，同样判断B是否是单例，且没有创建完毕，如果是，那么就会把B的beanFactory存入三级缓存
    //5、B开始处理@Autowired注解，开始注入A属性，于是依次从一级缓存、二级缓存查找A属性，都没有就尝试从三级缓存获取A的beanFactory，通过beanFactory.getObject()方法获取A属性，
    //  接下来把A存入二级缓存，清除三级缓存,此时若a被代理，则会返回代理对象（aop）。因为此时能获取到A，所以B的A属性能填充成功，B接着执行初始化，B处于实例化、初始化都完成的完全状态
    //6、B执行addSington(),把完全状态的B存入一级缓存，清空二三级缓存(实际只有三级有值)
    //7、A继续开始填充B属性，于是调用beanFactory.getBean()获取B，第六步已经把B存入一级缓存，此时直接返回，填充成功，继续执行初始化，得到一个完全状态的A
    //8、A执行addSington(),把完全状态的A存入一级缓存，清空二三级缓存(实际只有二级有值)
    //9、第二次遍历，开始获取B，此时一级缓存中有B，直接返回。

    //构造器造成的循环依赖三级缓存解决不了，为什么？
    //答：因为构造器循环依赖是发生在bean实例化阶段，此时连早期对象都还没创建出来，拿什么放到三级缓存。三级缓存只能是在bean实例化之后，才能起到作用

    //为什么要把B放入二级缓存？
    //答：主要是怕还有其他的循环依赖，如果还有的话，直接从二级缓存中就能拿到早期的AService对象

    //步骤6中，为什么要清空二三级缓存？
    //答：因为后续其他bean中也需要注入B时，会按顺序从一级缓存直到三级缓存查找，一级缓存有了，二三级缓存中的就不需要了，节省空间

    //不用三级缓存，只用二级缓存能不能解决循环依赖？
    //答：不能，因为通过ObjectFactory获取的Bean可能是两种类型，第一种就是实例化阶段创建出来的对象，还是一种就是实例化阶段创建出来的对象的代理对象。至于是不是代理对象，取决于你的配置，如果添加了事务注解又或是自定义AOP切面，那就需要代理。假设舍弃第三级缓存，也就是没有ObjectFactory，那么就需要往第二缓存放入早期的Bean，那么是放没有代理的Bean还是被代理的Bean呢，这是在后面的属性注入阶段，处理注解的时候才能分辨的？
    //1）如果直接往二级缓存添加没有被代理的Bean，那么可能注入给其它对象的Bean跟最后最后完全生成的Bean是不一样的，因为最后生成的是代理对象，这肯定是不允许的；
    //2）那么如果直接往二级缓存添加一个代理Bean呢？
    //● 假设没有循环依赖，提前暴露了代理对象，那么如果跟最后创建好的不一样，那么项目启动就会报错，
    //● 假设没有循环依赖，使用了ObjectFactory，那么就不会提前暴露了代理对象，到最后生成的对象是什么就是什么，就不会报错，
    //● 如果有循环依赖，不论怎样都会提前暴露代理对象，那么如果跟最后创建好的不一样，那么项目启动就会报错
    //通过上面分析，如果没有循环依赖，使用ObjectFactory，就减少了提前暴露代理对象的可能性，从而减少报错的可能。
    //第三级缓存就是为了避免过早地创建代理对象，从而避免没有循环依赖过早暴露代理对象产生的问题，而第二级缓存就是防止多次创建代理对象，导致对象不同。














}
