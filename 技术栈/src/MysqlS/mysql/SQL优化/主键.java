package MysqlS.mysql.SQL优化;

public class 主键 {
    //主键优化:
    //●数据组织方式:
    // 在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table l0T)。

    //页:页可以为空,也可以填充一-半,也可以填充100%。每个页包含了2~N行数据(如果一行数据多大, 会行溢出),根据主键排列。页之间有联系
    //●页分裂
    //主键乱序插入 会发生 页分裂

   //●页合并
    //当删除一行记录时,实际上记录并没有被物理删除,只是记录被标记(flaged) 为删除并且它的空间变得允许被其他记录声明使用。
    //当页中删除的记录达到MERGE__THRESHOLD (默认为页的50%),InnoDB会开始寻找最靠近的页( 前或后)看看是否可以将两个页合并以优化空间使用。
    //例:
    // 如果第N页使用了不到一半的空间，第N-1页又达到了足够的删除数量，且同样处于50%使用以下，这时 InnoDB 会尝试将这两页合并；
    // 合并后，第N-1页保留它之前的数据，并且容纳来自第N页的数据，同时，第N页变成一个空页，可以接纳新数据。
    //知识小贴士:
    //MERGE_ THRESHOLD:合并页的阈值，可以自己设置，在创建表或者创建索引时指定。

    //●主键设计原则
    //➢满足业务需 求的情况下，尽量降低主键的长度。
    //➢插入数据时， 尽量选择顺序插入,选择使用AUTO_ INCREMENT自增主键。
    //➢尽量不要使 用UUID做主键或者是其他自然主键,如身份证号。
    //➢业务操作时, 避免对主键的修改。

    /*
    页分裂:
        使用索引时，一个最基础的条件是，后面数据页中的数据行的主键值要大于前一个数据页中数据行的主键值；
        至于原因，其实索引简单来说，就是一遍一遍过筛子，通过二分法的逻辑不断减少要筛选的数据，
        而真实数据是按主键顺序存储的，所以主键值就是筛选标准，以便尽快定位我们需要的数据；

        我们假设如下的前两行数据已满足凑成一页的条件：
        如果我们设置了主键ID自定义，非自增，在已经插入了1、5、6、7(已分为两页)等ID的情况下，再插入ID2，就会触发页分裂；
        因为我们需要保证，后一个数据页中的所有主键值要比前一个数据页中的主键值大；
        这时我我们需要把2插入到1的后面，5、6、7等ID依次后移；
        注意，这里不是单纯的移动ID，而是要带着数据一起搬家！
        另外，每一行数据所占用的空间是不固定的，有可能移动之后，一页空间存不下5、6、7三条数据，需要同时生成第三页存放7ID;
        如果第三页已经存在了咋办，那就得生成第N页，同时修改第二、三页和第N页的指针，调整到符合要求；
        所以如果插入的主键是乱序，为满足索引条件，可能会产生频繁的页分裂，从而导致更新效率变低；
        当然了，真正的页分裂要比上面所说的复杂很多，但本质是通过这种逻辑来完成页分裂的。

     */


}
