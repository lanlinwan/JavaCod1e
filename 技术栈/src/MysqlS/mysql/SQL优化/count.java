package MysqlS.mysql.SQL优化;

public class count {
    //count优化:

    //➢MyISAM 引擎把一-个表的总行数存在了磁盘上,因此执行count(*)的时候会直接返回这个数,效率很高;
    //➢InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。
    //优化思路:自己计数。

    //●count的几种用法
    //➢count()是一一个聚合函数,对于返回的结果集，--行行地判断,
    // 如果count函数的参数不是NULL,累计值就加1,否则不加,最后返回累计值。
    //➢用法: count (*) 、count (主键)、count (字段)、count (1)

    //count的几种用法:
    //➢count (主键)
    //InnoDB引擎会遍历整张表,把每一-行的 主键id值都取出来,返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)。

    //➢count (字段)
    //没有not null约束: InnoDB引擎会遍历整张表把每- -行的字段值都取出来, 返回给服务层,服务层判断是否为null,不为null, 计数累加。
    //有not null约束: InnoDB 引擎会遍历整张表把每一行的字 段值都取出来,返回给服务层，直接按行进行累加。

    //➢count (1)
    //InnoDB引擎遍历整张表,但不取值。服务层对于返回的每一行，放--个数字“1” 进去，直接按行进行累加。

    //➢count (*)
    //InnoDB引擎并不会把全部字段取出来，而是专门做了优化,不取值，服务层直接按行进行累加。

    //按照效率排序的话，count(字段) < count(主键id) < count(1)≈count(*)，所以尽量使用count(*)。
    //数据量不大，我们尽量用 count (*) 实现计数；数据量很大的情况考虑新建 MySQL 表存储计数，用事务的原子性和隔离性解决。
}

