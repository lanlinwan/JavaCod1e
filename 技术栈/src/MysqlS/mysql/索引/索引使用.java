package MysqlS.mysql.索引;

public class 索引使用 {

    //●单列索引与联合索引
    //单列索引:即一个索引只包含单个列。
    //联合索引:即一个索引包含了多个列。
    //在业务场景中,如果存在多个查询条件,考虑针对于查询字段建立索引时,建议建立联合索引，而非单列索引。

    //●覆盖索引
    // 尽量使用覆盖索引(查询使用了索引,并且需要返回的列,在索引中已经全部能够找到),减少使用select *  where ...

    //●SQL提示
    //SQL提示,是优化数据库的一个重要手段,在SQL语句中加入人为的提示达到优化操作的目的

    // use index:建议MySQL使用某个索引
    //   select * from 表名  use index(索引名) where 条件

    // ignore index:建议MySQL忽略某个索引
    //   select * from 表名  ignore index(索引名) where 条件

    // force index:强制MySQL使用某个索引
    //   select * from 表名  force index(索引名) where 条件

    //●前缀索引
    //当字段类型为字符串(varchar, text等) 时，有时候需要索引很长的字符串，这会让索引变得很大，查询时,浪费大量的磁盘I0，
    //影响查询效率。此时可以只将字符串的一部分前缀,建立索引,这样可以大大节约索引空间，从而提高索引效率。
    //➢语法
    //create index 索引名 on 表明(字段名(n));
    //➢前缀长度
    //可以根据索引的选择性来决定,而选择性是指不重复的索引值(基数)和数据表的记录总数的比值，索引选择性越高则查询效率越高,
    //唯一索引的选择性是1,这是最好的索引选择性，性能也是最好的。
    //select count(distinct email) / count(*) from user ;
    //select count(distinct substring(email,1,5)) / count(*) from user ;

//索引失效情况:

    //●最左前缀法则
    //如果使用了多列(联合索引)，要遵守最左前缀法则。
    //最左前缀法则指的是查询从索引的最左列开始(实际写的时候 where顺序可以不考虑,但必须存在;order by顺序有意义的要考虑)，
    // 并且不跳过索引中间的列。如果跳跃某一列，索引将部分失效(后面的字段索引失效)。

    //●范围查询
    //联合索引中，出现范围查询(>, <),范围查询右侧的列索引失效(自己不会失效)
    // 创建的联合索引中，务必把范围涉及到的字段写在最后，然后将范围查询条件放置where语句最后
    // 加上等号可以具体定位到叶子链表中的具体节点，然后顺着往后遍历就可以了，不加等号，如果后面列索引不失效会出现很多重复的情况，遍历耗时更多

    //●没覆盖索引时，“不等于( != 或者<>)” 导致索引失效
    //因为“不等于”不能精准匹配，全表拉描二级索弓|树再回表效率不如直接全表扫描聚簇索引树。但使用
    //覆盖索引时，联合索引数据量小,加载到内存所需空间比聚簇索引树小，且不需要回表,索效率优
    //于全表扫描聚簇索引树。

    //●没覆盖索引时，is not null、not like导致索引失效
    // 因为is not null、not like不能精准匹配，全表扫描二级索引树再回表效率不如直接全表扫描聚簇索引树。
    // 但使用覆盖索引时，联合索引数据量小，加载到内存所需空间比聚簇索引树小，且不需要回表，索引效率优于全表扫描聚簇索引树。


    //●索引列运算
    //不要在索引列上进行运算操作,索引会失效

    //●类型隐式转换:例如字符串不加引号
    //字符串类型字段使用时,不加引号,索引将失效

    //●模糊查询
    //仅仅尾部模糊查询(查询字符串长度过短会失效),索引不会生效,头部模糊匹配或者中间带%,索引失效

    //●WHERE 子句中的 OR
    //用or分开的条件,如果or的条件中有一个列没有索引,那么涉及的索引会失效

    //●数据分布影响
    //如果MySQL评估使用索引比全表更慢,则不使用索引
    //比如:查询一个 user表 有索引的 age数值列[2,5,7,8,10]
    //    select * from user where age>1;
    //底层B+Tree 是顺序链表 当Mysql发现 全部的值都>1,就直接走全表扫描,根据索引还要进行一次回表查询





}
