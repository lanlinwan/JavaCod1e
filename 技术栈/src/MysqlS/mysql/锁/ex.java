package MysqlS.mysql.锁;

public class ex {
    /*
    1、 select * from t where id = 9;

    2、 delete from t where id = 9;

    以上两条SQL会加锁么？如果会，那么加的是什么锁？

    对于以上两条SQL语句是否加锁问题，我们可以从一下几个方面进行回答：

    由于在InnoDB存储引擎下，读已提交和可重复读隔离级别下select操作均不加锁，所以接下来我们着重分析SQL语句2。

    1、在读已提交隔离级别下

        1）id是主键时
            如果id是主键，那读已提交隔离级别下，给定SQL2：delete from t where id = 9 ;
           只需要将主键上id=9的记录加上写锁即可。

        2）id不是主键，而是唯一索引时
            由于id是二级唯一索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=9的记录后，
            首先会将二级唯一索引上的id=9索引记录加上写锁，
            同时，会读取到该二级唯一索引树叶子节点上的主键值，然后根据主键值去聚簇索引中找到对应的主键索引项并加写锁。

        3）id为非唯一索引（即普通索引）时
            若id列上有非唯一索引，那么对应的所有满足SQL查询条件（即id=9）的记录，都会被加锁。
            同时，这些记录在主键索引（即聚簇索引）上的记录，也会被加锁。

        4）id列上无索引时
            若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。
            因此每条记录，无论是否满足条件，都会被加上写锁。但是，为了效率考量，MySQL做了优化，
            对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的 加锁/放锁动作不会省略。

    2、在可重复读隔离级别下

        1）id是主键时
            与读已提交隔离级别下id是主键时的情况一致。

        2）id不是主键，而是唯一索引时
            与读已提交隔离级别下id不是主键，而是唯一索引时的情况一致。

        3）id为非唯一索引（即普通索引）时
            此情况下，对应SQL语句：delete from t where id = 9;
            首先，通过id索引定位到第一条满足where条件的记录，加记录上的写锁，加GAP上的间隙锁，
            然后加主键聚簇索引上的记录写锁，然后返回；然后读取下一条，重复进行。
            直至进行到第一条不满足条件的记录，此时，不需要加记录写锁，但是仍旧需要加间隙锁，最后返回结束。

        4）id列上无索引时
            如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有间隙，杜绝所有的并发“更新/删除/插入”操作。

     */
}
