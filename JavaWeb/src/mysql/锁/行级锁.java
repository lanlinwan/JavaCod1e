package mysql.锁;

public class 行级锁 {
    //行级锁:每次操作锁住对应的行数据。锁定粒度最小,发生锁冲突的概率最低,并发度最高。
    //      这使得多个事务可以并发地访问同一张表的不同行，提高了并发性和数据一致性。应用在InnoDB存储引擎中。
    //InnoDB的数据是基于索引组织的,行锁是通过对索引.上的索引项加锁来实现的，而不是对记录加的锁。
    //  对于行级锁,主要分为以下三类:
    //1.行锁(Record Lock) :锁定单个行记录的锁，防止其他事务对此行进行update和delete。 在RC、RR隔离级别下都支持。
    //2.间隙锁 (Gap Lock) :锁定索引记录间隙(不含该记录) ,确保索引记录间隙不变,防止其他事务在这个间隙进行insert,产生幻读。在RR隔离级别下都支
    //3.临键锁 (Next-Key Lock) :行锁和间隙锁组合,同时锁住数据,并锁住数据前面的间隙Gap。在RR隔离级别下支持。

    //●行锁
    //InnoDB实现了以下两种类型的行锁: .
    //1.共享锁(S) :其他事务也可以继续对该记录加S型记录锁（S型与S锁兼容）,但是不可以对该记录加X型记录锁(S型与 X 锁不兼容）;
    //2.排他锁 (X):允许获取排他锁的事务更新数据,阻止其他事务获得相同数据集的共享锁和排他锁。

    //SQL              行锁类型         说明
    //INSERT ...       排他锁        自动加锁
    //UPDATE ..        排他锁        自动加锁
    //DELETE ..        排他锁        自动加锁
    //SELECT (正常)    不加任何锁
    //SELECT ..LOCK IN SHARE MODE  共享锁      需要手动在SELECT之后加LOCK IN SHARE MODE
    //SELECT..FOR UPDATE  排他锁    需要手动在SELECT之后加FOR UPDATE
    //●行锁-演示
    //默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使 用next-key锁进行搜索和索引扫描，以防止幻读。
    //1.针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。
    //2.InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据,那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。
    //注意:
    //假如⼀张表没有索引，MySQL会进⾏锁表(其实锁住的是隐藏列ROW ID的主键索引)
    //假如我们对辅助索引加锁，那么辅助索引所对应的主键索引也会被锁住
    //主键索引被锁住，实际上就等于是整条记录都被锁住了(主键索引叶⼦节点存储了整条数据)

    //●间隙锁演示
    //默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使 用next-key锁进行搜索和索引扫描，以防止幻读。
    //1.索引上的等值查询,查询不到 加锁时,优化为间隙锁。
    //2.间隙锁,它锁定⼀段范围内的索引记录(锁的是两个值之间的空隙) ,间隙锁唯一目的是防止其他事务插入间隙。
    //3.间隙锁可以共存，-个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。
    //4.之所以会⽤到间隙锁就是没有命中数据的时候，所以并没有必要去阻塞读，也没有必要阻塞其他事务对同⼀个间隙加锁

    //●临键锁演示:
    //临键锁与间隙锁的不同之处在于，他所锁定的不只是一个范围，还包括了锁定记录本身。
    //1.索引上的等值查询(非唯一普通索引)，查询不到时，临键锁退化为间隙锁。
    //2.临键锁即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。
    //3.临键锁之间的X，S锁之间的互斥关系同样遵循行锁之间的互斥关系


    //For Update与其他锁定方式的区别
    //1. For Update是一种排它锁定方式，只有被锁定的行才能进行修改操作。
    //   而共享锁定方式允许多个事务同时读取同一行数据，但是不允许对其进行修改。
    //2. For Update锁定方式可以避免出现脏读、可重复读和幻读等并发问题，
    //   因为它会在读取某一行数据时将其锁定，直到事务结束或提交之前才释放锁定。
    //3. For Update锁定方式可能会导致死锁问题，因为多个事务可能会互相等待对方释放锁定。
    //   而其他锁定方式如共享锁定则不存在这个问题。
    //4. For Update锁定方式的性能较差，因为它需要在读取数据时进行锁定操作,
    //   增加了系统的开销。而其他锁定方式如共享锁定则没有这个问题。

}
