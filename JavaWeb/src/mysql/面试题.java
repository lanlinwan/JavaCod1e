package mysql;

public class 面试题 {
    //普通索引和唯一索引该怎么选择?
    //查询
    //  当普通索引为条件时查询到数据会一直扫描，直到扫完整张表；
    //  当唯一索引为查询条件时，查到该数据会直接返回，不会继续扫表；
    //更新
    //  普通索引会直接将操作更新到 change buffer 中，然后结束
    //  唯一索引需要判断数据是否冲突
    //所以唯一索引更加适合查询的场景，普通索引更适合插入的场景。

    // 为什么InnoDB存储引擎选择使用B+tree索引结构?
    //➢相对于二叉树，层级更少,搜索效率高;
    //➢对于B-tree,无论是叶子节点还是非叶子节点，都会保存数据,这样导致一
    //  页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的.
    //  高度，导致性能降低;
    //➢相对Hash索引，B+tree支持 范围匹配及排序操作;


    //为什么不用二叉树或者红黑树
    //二叉树树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度）,并且IO代价高
    //红黑树树的高度随着数据量增加而增加，IO代价高

    //B+树和B-树的主要区别如下：
    //  B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。
    //  B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。
    //  查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束
    //  B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。
    //

    //B树与B+树对比:
    //●①磁盘读写代价B+树更低:
    //      B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。
    //●②查询效率B+树更加稳定:
    //     数据都存储到叶子节点，都从根开始找到叶子节点，查找路径差不多，所以效率稳定。
    //●③B+树便于扫库和区间查询:
    //     底层是双向指针的链表，进行范围查询直接从叶子节点进行查询,不需要每次从根节点开始获取数据。


    //说一说drop、delete与truncate的区别？
    //1、dropDrop命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。
    //2、truncate:
    //  Truncate删除表中的所有数据，这个操作不能回滚,也不会触发这个表上的触发器，
    //  TRUNCATE比delete更快，占用的空间更小。
    //3、delete:
    //  Delete用来删除表的全部或者一部分数据行, 执行delete之 后,用户需要提交(commmit)或者回滚
    //  (rollback)来执行删除或者撤销删除。会触发这个表上所有的delete触发器

    //1、三大范式
    //1NF(第一范式): 属性(对应于表中的字段)不能再被分割，也就是这个字段只能是一个值, 不能
    //             再分为多个其他的字段了。1NF是所有关系型数据库的最基本要求，也就是说关系型数据库中创
    //             建的表一定满足第一范式。
    //2NF(第二范式): 2NF 要求数据库表中的每个实例或行必须可以被惟一地区分，2NF 在1NF的基
    //             础上增加了一个列，这个列称为主键，非主属性都依赖于主键。
    //3NF(第三范式): 3NF在2NF的基础之上，要求每列都和主键列直接相关，而不是间接相关，即
    //             不存在其他表的非主键信息。
    //在开发过程中，并不一定要满足三大范式，有时候为了提高查询效率，可以在表中冗余其他表的字段。
}
